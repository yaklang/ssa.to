<!doctype html>
<html lang="zh" dir="ltr" class="docs-wrapper plugin-docs plugin-id-static-analysis-guide docs-version-current docs-doc-page docs-doc-id-intro" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.6.1">
<title data-rh="true">第一章：编译与静态代码分析概论 | SSA.to</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ssa.to/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://ssa.to/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://ssa.to/static-analysis-guide/intro"><meta data-rh="true" property="og:locale" content="zh"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-static-analysis-guide-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-static-analysis-guide-current"><meta data-rh="true" property="og:title" content="第一章：编译与静态代码分析概论 | SSA.to"><meta data-rh="true" name="description" content="在我们致力于打造一个“有人用”的编程语言和编译器技术体系的过程中，随着逐步进入“编译与静态分析”的深水区，发现了很多缺乏实践导致理论僵化的问题。虽然我们使用“代码和项目”去填补了很多编译与分析深水区的空白，但是我们仍然希望这些僵化的理论可以获得更新，让现代化的静态代码分析重新获得生命力。"><meta data-rh="true" property="og:description" content="在我们致力于打造一个“有人用”的编程语言和编译器技术体系的过程中，随着逐步进入“编译与静态分析”的深水区，发现了很多缺乏实践导致理论僵化的问题。虽然我们使用“代码和项目”去填补了很多编译与分析深水区的空白，但是我们仍然希望这些僵化的理论可以获得更新，让现代化的静态代码分析重新获得生命力。"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ssa.to/static-analysis-guide/intro"><link data-rh="true" rel="alternate" href="https://ssa.to/static-analysis-guide/intro" hreflang="zh"><link data-rh="true" rel="alternate" href="https://ssa.to/en/static-analysis-guide/intro" hreflang="en"><link data-rh="true" rel="alternate" href="https://ssa.to/static-analysis-guide/intro" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.b1561eee.css">
<script src="/assets/js/runtime~main.8ddcc614.js" defer="defer"></script>
<script src="/assets/js/main.a5137384.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo-dark.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">SSA.to</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/static-analysis-guide/intro">静态代码分析教程</a><a class="navbar__item navbar__link" href="/docs/intro">代码扫描基础使用</a><a class="navbar__item navbar__link" href="/syntaxflow-guide/intro">SyntaxFlow 文档</a><a class="navbar__item navbar__link" href="/cookbook">SyntaxFlow 手册离线 PDF</a><a class="navbar__item navbar__link" href="/codeAnalysis">Code Analysis NOW!</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yaklang/ssa.to" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>中文</a><ul class="dropdown__menu"><li><a href="/static-analysis-guide/intro" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh">中文</a></li><li><a href="/en/static-analysis-guide/intro" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li></ul></div><div class="navbarSearchContainer_dCNk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_eExm"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/static-analysis-guide/intro">第一章：编译与静态代码分析概论</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/static-analysis-guide/compile-ssa-form">第二章：详解静态单赋值形式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/static-analysis-guide/ssa-for-advanced-language">第三章：高级语言的 SSA 构建（一）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/static-analysis-guide/ssa-for-advanced-language-2">第三章：高级语言的 SSA 构建（二）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/static-analysis-guide/deep-dive-into-ssa-closure">第四章：SSA 深水区 - 分析闭包函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/static-analysis-guide/deep-dive-into-ssa-oop">第五章：SSA 深水区 - OOP与无类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/static-analysis-guide/deep-dive-into-ssa-use-def-chain">第六章：SSA 深水区 - 数据流分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/static-analysis-guide/deep-dive-into-ssa-cross-procedure">第七章：SSA 深水区 - 跨过程分析</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">第一章：编译与静态代码分析概论</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>第一章：编译与静态代码分析概论</h1></header>
<p>在我们致力于打造一个“有人用”的编程语言和编译器技术体系的过程中，随着逐步进入“编译与静态分析”的深水区，发现了很多缺乏实践导致理论僵化的问题。虽然我们使用“代码和项目”去填补了很多编译与分析深水区的空白，但是我们仍然希望这些僵化的理论可以获得更新，让现代化的静态代码分析重新获得生命力。</p>
<hr>
<!-- -->
<div class="tableOfContentsInline_prmo"><ul class="table-of-contents"><li><a href="#编译技术">编译技术</a></li><li><a href="#静态代码分析与编译技术历史关系">静态代码分析与编译技术历史关系</a><ul><li><a href="#1960年代的编译器前端与后端">1960年代的编译器前端与后端</a></li><li><a href="#1970年代后中端概念出现">1970年代后中端概念出现</a></li><li><a href="#1980年代到1990年代优化技术快速发展ssa-引入">1980年代到1990年代“优化”技术快速发展，SSA 引入</a></li></ul></li><li><a href="#静态代码分析技术与-ssa-form">静态代码分析技术与 SSA-Form</a><ul><li><a href="#ssa-是何方神圣">SSA 是何方神圣？</a></li><li><a href="#理解ssa形式在优化算法中的优势以常量传播优化为例">理解SSA形式在优化算法中的优势（以常量传播优化为例）</a></li></ul></li><li><a href="#参考文献">参考文献</a></li></ul></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="编译技术">编译技术<a href="#编译技术" class="hash-link" aria-label="编译技术的直接链接" title="编译技术的直接链接">​</a></h2>
<p>编译技 术被誉为计算机科学的&quot;皇后&quot;，其发展历程实际上就是计算机科学发展史的缩影。它不仅是计算机科学专业的必修课程，更是推动整个计算机科学发展的核心技术之一。在比较经典的编译架构中，我们会主要分割为三个部分（也称三段式编译器）：前端，中端（中间代码生成与优化），后端。</p>
<p>严格区分的前中后端，让编译器在编译过程中进行代码优化变得可能，尤其是在1990年左右静态单赋值形式（SSA-Form）的引入，简化了大量的优化算法，极大提升了优化效率，并且现今演变为编译器中端的标准形式。</p>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="静态代码分析与编译技术历史关系">静态代码分析与编译技术历史关系<a href="#静态代码分析与编译技术历史关系" class="hash-link" aria-label="静态代码分析与编译技术历史关系的直接链接" title="静态代码分析与编译技术历史关系的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="1960年代的编译器前端与后端">1960年代的编译器前端与后端<a href="#1960年代的编译器前端与后端" class="hash-link" aria-label="1960年代的编译器前端与后端的直接链接" title="1960年代的编译器前端与后端的直接链接">​</a></h3>
<p>20世纪六十年代是编译器技术的早期，在这个阶段，编译器中端并不是一个明确的概念，当时的编译器主要关注前端的语法分析和后端的代码生成。但随着程序优化需求的增加，中端的雏形开始出现。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="1970年代后中端概念出现">1970年代后中端概念出现<a href="#1970年代后中端概念出现" class="hash-link" aria-label="1970年代后中端概念出现的直接链接" title="1970年代后中端概念出现的直接链接">​</a></h3>
<p>直接通过AST生成目标代码（汇编）变得非常困  难，引入一个中间表示层（Intermediate Representation, IR）之后可以很好的解决这个问题。早期的 IR 常见三地址码和四元式的形式。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="1980年代到1990年代优化技术快速发展ssa-引入">1980年代到1990年代“优化”技术快速发展，SSA 引入<a href="#1980年代到1990年代优化技术快速发展ssa-引入" class="hash-link" aria-label="1980年代到1990年代“优化”技术快速发展，SSA 引入的直接链接" title="1980年代到1990年代“优化”技术快速发展，SSA 引入的直接链接">​</a></h3>
<p>在20世纪80年代到90年代初期，编译器优化技术经历了一次革命性的发展。这个时期出现了一系列重要的优化技术，包括数据流分析（如到达定义分析、活跃变量分析）、经典优化技术（如常量折叠、死代码消除、公共子表达式消除）、基于控制流图的优化，以及过程间分析等。但最具革命性的突破是1991年静态单赋值形式（SSA Form）的引入。SSA形式的核心思想是：程序中的每个变量只能被赋值一次。这个看似简单的约束却带来了深远的影响。</p>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="静态代码分析技术与-ssa-form">静态代码分析技术与 SSA-Form<a href="#静态代码分析技术与-ssa-form" class="hash-link" aria-label="静态代码分析技术与 SSA-Form的直接链接" title="静态代码分析技术与 SSA-Form的直接链接">​</a></h2>
<p>虽然各种以优化为目的的静态代码分析技术的提出比 SSA-Form 要更早，但是 SSA 技术实际上应该是更底层的理论，SSA 技术的出现对非 SSA 技术的现有算法进行了大幅度的优化。SSA 形式作为一种中间表示（IR）的特殊形式，其核心特点是确保每个变量只被赋值一次，这一特性使得数据流分析变得更加简单和高效。在 SSA 出现之前，传统的数据流分析需要反复迭代才能  确定变量的定义和使用关系，而 SSA 形式通过引入 φ（phi）函数，优雅地解决了控制流汇合点上的变量版本选择问题。</p>
<p>虽然 SSA 形式的引入会增加一定的内存开销（主要是由于变量的多个版本和 φ 函数的引入），但其带来的优化效果和算法简化的好处远远超过了这些开销。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ssa-是何方神圣">SSA 是何方神圣？<a href="#ssa-是何方神圣" class="hash-link" aria-label="SSA 是何方神圣？的直接链接" title="SSA 是何方神圣？的直接链接">​</a></h3>
<p>SSA-Form（静态单赋值形式）是一种在编译器设计中广泛使用的中间表示（IR）技术，它通过确保程序中的每个变量在其生命周期内仅被赋值一次，从而显著简化了编译器的优化和分析过程。这种形式最初由 Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman 和 F. Kenneth Zadeck 在1991年提出，并迅速成为现代编译器架构中的一个核心组成部分。</p>
<p>在实际应用中，SSA-Form不仅被用于传统的编译器中，如GCC和LLVM，它还被广泛应用于各种现代编程语言的实现和新兴的编译技术中，包括即时编译（JIT）和动态优化。SSA的普及和效果证明了其在提高编译器性能和代码优化方面的关键作用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="理解ssa形式在优化算法中的优势以常量传播优化为例">理解SSA形式在优化算法中的优势（以常量传播优化为例）<a href="#理解ssa形式在优化算法中的优势以常量传播优化为例" class="hash-link" aria-label="理解SSA形式在优化算法中的优势（以常量传播优化为例）的直接链接" title="理解SSA形式在优化算法中的优势（以常量传播优化为例）的直接链接">​</a></h3>
<p>我们以常量传播优化为例，来分析对比 SSA 形式下的优化与非 SSA 形式下的优化有何异同。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是常量传播优化">什么是常量传播优化<a href="#什么是常量传播优化" class="hash-link" aria-label="什么是常量传播优化的直接链接" title="什么是常量传播优化的直接链接">​</a></h4>
<blockquote>
<p>常量传播(Constant Propagation)是编译器优化中的一项关键技术[1]，它通过在编译时识别和传播程序中的常量值来减少运行时计算开销。这种优化属于数据流分析范畴，主要包括简单常量传播、条件常量传播和稀疏条件常量传播等类型[2]。在实现过程中，编译器首先构建控制流图，然后通过迭代计算来传播常量信息，最终实现代码优化[3]。例如，将 int x = 10; int y = x + 5; 优化为 int x = 10; int y = 15;。常量传播不仅能直接提升程序性能，还能触发其他优化机会，如死代码消除和循环优化[4]。然而，这种优化也面临着一些挑战，如指针别名分析的影响和函数调用的副作用等[5]。在现代编译器中，常量传播已成为优化流水线中不可或缺的一环，对提高程序执行效率具有重要作用。</p>
<p>参考文献：</p>
<ol>
<li>Wegman, M. N., &amp; Zadeck, F. K. (1991). Constant propagation with conditional branches. ACM Transactions on Programming Languages and Systems (TOPLAS), 13(2), 181-210.</li>
<li>Muchnick, S. S. (1997). Advanced compiler design and implementation. Morgan Kaufmann. Chapter 12: Data-Flow Analysis.</li>
<li>Cooper, K. D., &amp; Torczon, L. (2011). Engineering a compiler. Elsevier. pp. 465-475.</li>
<li>Aho, A. V., Lam, M. S., Sethi, R., &amp; Ullman, J. D. (2006). Compilers: Principles, techniques, and tools (2nd edition). Addison Wesley. Chapter 9: Data-Flow Analysis.</li>
<li>Click, C., &amp; Cooper, K. D. (1995). Combining analyses, combining optimizations. ACM Transactions on Programming Languages and Systems (TOPLAS), 17(2), 181-196.</li>
</ol>
</blockquote>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="非ssa形式下的 常量传播">非SSA形式下的常量传播<a href="#非ssa形式下的常量传播" class="hash-link" aria-label="非SSA形式下的常量传播的直接链接" title="非SSA形式下的常量传播的直接链接">​</a></h4>
<p>在非SSA（静态单赋值）形式下进行常量传播时，会面临一些处理上的困难。常量传播是一种优化技术，通过用常数值替换已知的常数变量来提高代码效率。但在非SSA形式中，由于变量可以被多次赋予不同的值，这使得追踪变量的值变得更为复杂。</p>
<p>以一个简单的代码示例来说明这一点：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1: x = 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2: y = x + 3  // 使用x的值计算y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3: x = 10     // x被重新赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4: z = x + y  // 计算z时，x已经是10，而y是基于x原来的值5计算得到的</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在这个例子中，变量<code>x</code>被赋值了两次，首先是5，然后是10。这种重赋值导致在进行数据流分析时必须非常小心地追踪每个变量在不同点上的值。在第2行，<code>y</code>的值根据第1行时<code>x</code>的值计算得出。但到了第4行，尽管<code>y</code>是基于<code>x</code>的旧值计算的，<code>x</code>的值已经更新为10。</p>
<p>这种情况下，算法需要正确分析和处理变量值的变化，确保在每个使用点正确理解变量的当前值。非SSA形式下的常量传播要求更细致的数据流分析，以保证优化的准确性和效果。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="ssa形式下的常量传播">SSA形式下的常量传播<a href="#ssa形式下的常量传播" class="hash-link" aria-label="SSA形式下的常量传播的直接链接" title="SSA形式下的常量传播的直接链接">​</a></h4>
<p>在SSA（静态单赋值）形式中，每个变量在其生命周期内仅被赋值一次，这一特性显著简化了编译器优化过程，如常量传播。在SSA形式下，变量的重命名清晰地标示了每个变量的定义和使用，从而消除了因变量重赋值带来的歧义。</p>
<p>考虑以下代码片段转换为SSA形式：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1: x₁ = 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2: y₁ = x₁ + 3   // 直接计算为8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3: x₂ = 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4: z₁ = x₂ + y₁  // 直接计算为18</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在此形式中，每个变量（如x₁、x₂、y₁、z₁）都具有单一的赋值点，使得它们的值在任何使用点都是预先确定的，完全无需迭代运算和进行值的抉择。</p>
<!-- -->
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="针对常量传播算法的优化">针对常量传播算法的优化<a href="#针对常量传播算法的优化" class="hash-link" aria-label="针对常量传播算法的优化的直接链接" title="针对常量传播算法的优化的直接链接">​</a></h4>
<p>SSA形式通过提供清晰的变量赋值和使用框架，极大地提高了编译器进行常量传播等优化的效率和准确性。这种方法不仅优化了程序执行效率，也简化了编译器的设计，使得代码分析和优化过程更加高效和可靠。结合上面的案例，主要优化点体现在下面两个方面：</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>主要优化点</div><div class="admonitionContent_BuS1"><ul>
<li><strong>显式数据流</strong>：变量的单一赋值明确了数据的流向，使得追踪变量值及其计算变得直接而清晰。</li>
<li><strong>计算简化</strong>：由于每个变量的值在定义时即已确定，常量传播可以在编译时直接计算出结果，如<code>y₁ = 8</code>和<code>z₁ = 18</code>，无需运行时计算。</li>
</ul></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考文献">参考文献<a href="#参考文献" class="hash-link" aria-label="参考文献的直接链接" title="参考文献的直接链接">​</a></h2>
<ol>
<li>
<p>Aho, A. V., Lam, M. S., Sethi, R., &amp; Ullman, J. D. (2006). Compilers: Principles, Techniques, and Tools. DOI: 10.1145/1538788.1538814</p>
</li>
<li>
<p>Allen, F. E. (1970). Control flow analysis. ACM Sigplan Notices. DOI: 10.1145/390013.808479</p>
</li>
<li>
<p>Cytron, R., Ferrante, J., Rosen, B. K., Wegman, M. N., &amp; Zadeck, F. K. (1991). Efficiently computing static single assignment form and the control dependence graph. DOI: 10.1145/115372.115320</p>
</li>
<li>
<p>Rosen, B. K., Wegman, M. N., &amp; Zadeck, F. K. (1988). Global value numbers and redundant computations. DOI: 10.1145/73560.73562</p>
</li>
<li>
<p>Wegman, M. N., &amp; Zadeck, F. K. (1991). Constant propagation with conditional branches. DOI: 10.1145/103135.103136</p>
</li>
</ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/yaklang/ssa.to/tree/main/static-analysis-guide/static-analysis-guide/intro.mdx" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">最后<!-- -->由 <b>v1ll4n</b> <!-- -->于 <b><time datetime="2024-11-19T09:24:25.000Z" itemprop="dateModified">2024年11月19日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--next" href="/static-analysis-guide/compile-ssa-form"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">第二章：详解静态单赋值形式</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#编译技术" class="table-of-contents__link toc-highlight">编译技术</a></li><li><a href="#静态代码分析与编译技术历史关系" class="table-of-contents__link toc-highlight">静态代码分析与编译技术历史关系</a><ul><li><a href="#1960年代的编译器前端与后端" class="table-of-contents__link toc-highlight">1960年代的编译器前端与后端</a></li><li><a href="#1970年代后中端概念出现" class="table-of-contents__link toc-highlight">1970年代后中端概念出现</a></li><li><a href="#1980年代到1990年代优化技术快速发展ssa-引入" class="table-of-contents__link toc-highlight">1980年代到1990年代“优化”技术快速发展，SSA 引入</a></li></ul></li><li><a href="#静态代码分析技术与-ssa-form" class="table-of-contents__link toc-highlight">静态代码分析技术与 SSA-Form</a><ul><li><a href="#ssa-是何方神圣" class="table-of-contents__link toc-highlight">SSA 是何方神圣？</a></li><li><a href="#理解ssa形式在优化算法中的优势以常量传播优化为例" class="table-of-contents__link toc-highlight">理解SSA形式在优化算法中的优势（以常量传播优化为例）</a></li></ul></li><li><a href="#参考文献" class="table-of-contents__link toc-highlight">参考文献</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer_jryj"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/community#%E5%BE%AE%E4%BF%A1%E4%BA%A4%E6%B5%81%E7%BE%A4">Wechat</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/yaklang/ssa.to" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"></div></div><div class="footer__copyright copyright_C_OK">Copyright © 2024 ssa.to, Powered by yaklang.io</div></footer></div>
</body>
</html>